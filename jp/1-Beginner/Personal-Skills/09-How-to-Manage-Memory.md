# How to Manage Memory
[//]: # (Version:1.0.0)
メモリは、あなたが使い果たしてはならない貴重なリソースです。しばらくそれを無視することはできますが、最終的にはメモリの管理方法を決定する必要があります。

単一のサブルーチンの範囲を超えて持続する必要がある領域は、しばしば* heap allocated *と呼ばれます。メモリのチャンクは役に立たないので、何も言及していないときは*ゴミ*です。あなたが使用しているシステムによっては、メモリがごみになってしまうときに、自分で明示的にメモリの割り当てを解除する必要があるかもしれません。より頻繁に*ガベージコレクタ*を提供するシステムを使用することができます。ガベージコレクタはゴミに気づいて、プログラマが要求するアクションなしにスペースを解放します。ガベージコレクションは素晴らしいです：エラーを減らし、コードの簡潔さと簡潔さを安くします。可能であれば使用してください。

しかし、ガベージコレクションであっても、すべてのメモリをゴミでいっぱいにすることができます。古典的な間違いは、ハッシュテーブルをキャッシュとして使用し、ハッシュテーブル内の参照を削除することを忘れてしまいます。参照が残っているので、指示対象は収集できないものの、役に立たない。これは*メモリリーク*と呼ばれます。メモリリークを早期に見つけて修正する必要があります。長時間稼動しているシステムでは、テストでメモリーが使い果たされることはありませんが、ユーザーは使い果たされます。

新しいオブジェクトの作成は、どのシステムでも適度に高価です。しかし、サブルーチンのローカル変数に直接割り当てられたメモリは、通常、それを解放する方針が非常に簡単なので、安価です。不要なオブジェクトの作成を避ける必要があります。

重要なケースは、一度に必要なオブジェクト数の上限を定義できるときです。これらのオブジェクトがすべて同じ量のメモリを占める場合は、それらをすべて保持するために、単一のメモリブロックまたはバッファを割り当てることができます。必要なオブジェクトは、このバッファ内で設定された回転パターンで割り当てられ解放されることがあります。したがって、リングバッファと呼ばれることもあります。これは通常、ヒープ割り当てよりも高速です。

ガベージコレクションに頼るのではなく、割り当てられたスペースを明示的に解放する必要がある場合があります。次に、割り当てられたメモリの各チャンクに慎重なインテリジェンスを適用し、適切なタイミングで割り当てを解除する方法を設計する必要があります。メソッドは、作成するオブジェクトの種類ごとに異なる場合があります。メモリ割り当て操作のすべての実行が、メモリ割り当て解除操作によって最終的に一致することを確認する必要があります。これは非常に難しいので、プログラマは参照カウントなどの基本的な形式のガーベジコレクションを実装するだけで済みます。

Next [How to Deal with Intermittent Bugs](10-How-to-Deal-with-Intermittent-Bugs.md)
